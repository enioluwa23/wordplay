{
    "docs": [
        {
            "location": "/",
            "text": "Wordplay\n\n\n\n\nPython package for word searching utilities.\n\n\nUsing a convenient API, you can filter a set of strings with detailed criteria. There are also more scrabble-like features such as getting all anagrams of a word.\n\n\nInstall\n\n\npip install wordplay\n\n\n\n\nBackground\n\n\nI initially built this as an algorithm solely to help my endeavors in word games such as Scrabble. It was useful for finding word combinations in every type of situation. However, I realized it could be used for many other purposes, such as filtering email addresses, phone numbers and any set of data really. So I decided to decouple the API from my personal use.\n\n\nUsage\n\n\nWords are stored in a \nDictionary\n object. Initialize the dictionary with a \nset\n of strings (there are no restrictions on what the string can contain) or \nDictionary()\n with no arguments to use the word set sourced from \nhere\n. In the future, I will amass a couple of word lists and make them options for initializing the dictionary.\n\n\nIf you do want restrictions on the string, see the documentation for the \nUtils\n module. For complex query parameters, you can use a \nCriteria\n object. The class uses the builder pattern, making it easy to construct search parameters.\n\n\nHere is a an example file:\n\n\nfrom __future__ import print_function\nfrom wordplay.dictionary import Dictionary\nfrom wordplay.criteria import Criteria\n\n\ndef main():\n    dictionary = Dictionary()\n\n    result = dictionary.get_words_with_any_letters('diction', 6)\n    print(result)\n    # ['diotic', 'dition', 'indico', 'indict', 'nidiot', 'odinic']\n\n    result = dictionary.get_words_with_any_letters('pox')\n    print(result)\n    # ['o', 'op', 'ox', 'p', 'po', 'pox', 'x']\n\n    result = dictionary.get_anagrams('aekst')\n    print(result)\n    # ['keats', 'skate', 'skeat', 'stake', 'steak', 'takes', 'teaks']\n\n    print('car' in dictionary)  # Dictionary is directly iterable\n    # True\n\n    criteria = Criteria()\n    criteria.begins_with('c').ends_with('s').contains('or')\n    criteria.contains_at(('o', 2), ('r', 4)).size_is(10)\n    result = dictionary.get_words(criteria)\n    print(result)\n    # ['corrosives', 'correlates', 'corrugates']\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n\nFor further example usage see the \nDocumentation\n.\n\n\nTo run tests, use \npytest\n.\n\n\nDocumentation\n\n\nAPI Reference\n\n\nLicense\n\n\nApache Software License",
            "title": "Home"
        },
        {
            "location": "/#wordplay",
            "text": "Python package for word searching utilities.  Using a convenient API, you can filter a set of strings with detailed criteria. There are also more scrabble-like features such as getting all anagrams of a word.",
            "title": "Wordplay"
        },
        {
            "location": "/#install",
            "text": "pip install wordplay",
            "title": "Install"
        },
        {
            "location": "/#background",
            "text": "I initially built this as an algorithm solely to help my endeavors in word games such as Scrabble. It was useful for finding word combinations in every type of situation. However, I realized it could be used for many other purposes, such as filtering email addresses, phone numbers and any set of data really. So I decided to decouple the API from my personal use.",
            "title": "Background"
        },
        {
            "location": "/#usage",
            "text": "Words are stored in a  Dictionary  object. Initialize the dictionary with a  set  of strings (there are no restrictions on what the string can contain) or  Dictionary()  with no arguments to use the word set sourced from  here . In the future, I will amass a couple of word lists and make them options for initializing the dictionary.  If you do want restrictions on the string, see the documentation for the  Utils  module. For complex query parameters, you can use a  Criteria  object. The class uses the builder pattern, making it easy to construct search parameters.  Here is a an example file:  from __future__ import print_function\nfrom wordplay.dictionary import Dictionary\nfrom wordplay.criteria import Criteria\n\n\ndef main():\n    dictionary = Dictionary()\n\n    result = dictionary.get_words_with_any_letters('diction', 6)\n    print(result)\n    # ['diotic', 'dition', 'indico', 'indict', 'nidiot', 'odinic']\n\n    result = dictionary.get_words_with_any_letters('pox')\n    print(result)\n    # ['o', 'op', 'ox', 'p', 'po', 'pox', 'x']\n\n    result = dictionary.get_anagrams('aekst')\n    print(result)\n    # ['keats', 'skate', 'skeat', 'stake', 'steak', 'takes', 'teaks']\n\n    print('car' in dictionary)  # Dictionary is directly iterable\n    # True\n\n    criteria = Criteria()\n    criteria.begins_with('c').ends_with('s').contains('or')\n    criteria.contains_at(('o', 2), ('r', 4)).size_is(10)\n    result = dictionary.get_words(criteria)\n    print(result)\n    # ['corrosives', 'correlates', 'corrugates']\n\n\nif __name__ == '__main__':\n    main()  For further example usage see the  Documentation .  To run tests, use  pytest .",
            "title": "Usage"
        },
        {
            "location": "/#documentation",
            "text": "API Reference",
            "title": "Documentation"
        },
        {
            "location": "/#license",
            "text": "Apache Software License",
            "title": "License"
        },
        {
            "location": "/api/dictionary/",
            "text": "Dictionary\n\n\n\nDictionary(self, word_list=None)\n\n\n\n\nClass providing utilities for finding words with criteria.\n\nget_words\n\n\nDictionary.get_words(self, criteria)\n\n\n\n\nGets words from its wordlist given valid search criteria.\n\n\nArgs:\n    criteria (\nCriteria\n): Object containing search parameters\n\n\nReturns:\n    A list of words from its wordlist matching the criteria\n\n\nRaises:\n    \nArgumentError\n: If arg is not of type Criteria\n\n\nget_words_with_any_letters\n\n\n\nDictionary.get_words_with_any_letters(self, word, length=None, sort_order=<SortOrder.ASCENDING: 1>, sort_type=<SortType.ALPHA: 2>)\n\n\n\n\nGets words from its wordlist that contain any of the letters in word\n\n\nArgs:\n    word (\nstr\n): Letters to pool words from\n\n\nReturns:\n    A list of words from its wordlist containing any letters in word\n\n\nRaises:\n    \nArgumentError\n\n\nget_words_within\n\n\n\nDictionary.get_words_within(self, word, length=None, sort_order=<SortOrder.ASCENDING: 1>, sort_type=<SortType.ALPHA: 2>)\n\n\n\n\nGets words from its wordlist that are substrings of word\n\n\nArgs:\n    word (\nstr\n): Letters to pool words from\n\n\nReturns:\n    A list of words from its wordlist that are substrings of word\n\n\nRaises:\n    \nArgumentError\n\n\nget_anagrams\n\n\n\nDictionary.get_anagrams(self, word, sort_order=<SortOrder.ASCENDING: 1>, sort_type=<SortType.ALPHA: 2>)\n\n\n\n\nGets all anagrams of a word from the wordlist\n\n\nArgs:\n    word (\nstr\n): Letters to pool words from\n\n\nReturns:\n    A list of words from its wordlist that are anagrams of word\n\n\nRaises:\n    \nArgumentError\n\n\nSortOrder\n\n\n\nSortOrder(self, /, *args, **kwargs)\n\n\n\n\nEnum class providing order options for sorting.\n\n\nOptions:\n\n\nASCENDING - A-Z, 0-9\n\n\nDESCENDING - Z-A, 9-0\n\n\nSortType\n\n\n\nSortType(self, /, *args, **kwargs)\n\n\n\n\nEnum class providing options for sorting.\n\n\nOptions:\n\n\nSIZE - Sort by Size\n\n\nALPHA - Sort in Alphabetical Order",
            "title": "Dictionary"
        },
        {
            "location": "/api/criteria/",
            "text": "wordplay.criteria\n\n\n\nCriteria\n\n\n\nCriteria(self, original=None)\n\n\n\n\nClass providing an interface for building search parameters.\n\nbegins_with\n\n\nCriteria.begins_with(self, arg)\n\n\n\n\nSet letter or alphabetic string the word should begin with.\n\nremove_begins_with\n\n\nCriteria.remove_begins_with(self, arg=None)\n\n\n\n\nRemove part or the whole of what the word should begin with.\n\nends_with\n\n\nCriteria.ends_with(self, arg)\n\n\n\n\nSet letter or alphabetic string the word should end with.\n\nremove_ends_with\n\n\nCriteria.remove_ends_with(self, arg=None)\n\n\n\n\nRemove part or the whole of what the word should end with.\n\ncontains\n\n\nCriteria.contains(self, *args)\n\n\n\n\nAdd letter(s) or alphabetic strings the word should contain.\n\ncontains_at\n\n\nCriteria.contains_at(self, *args)\n\n\n\n\nAdd tuple(s) of (str letter, int position_in_word) e.g (a, 1)\n\nremove_contains\n\n\nCriteria.remove_contains(self, *args)\n\n\n\n\nRemove part or the whole of what the word should contain.\n\nremove_contains_at\n\n\nCriteria.remove_contains_at(self, *args)\n\n\n\n\nRemove part or the whole positional criteria the word should fulfill.\n\n\nsize_is\n\n\n\nCriteria.size_is(self, arg)\n\n\n\n\nSet what the int size/length of the word should be.\n\nremove_size\n\n\nCriteria.remove_size(self)\n\n\n\n\nRemove the size restriction on the word.",
            "title": "Criteria"
        },
        {
            "location": "/api/utils/",
            "text": "Utils\n\n\n\nUtils(self, /, *args, **kwargs)\n\n\n\n\nClass providing utility functions for argument validation.\n\nvalidate_args\n\n\nUtils.validate_args(*args)\n\n\n\n\nVerifies string, tuple and list args are valid string constructors.\n\n\nArgs:\n    *args (\ntuple\n): Variadic tuple of arguments to be validated\n\n\nRaises:\n    \nArgumentError\n: if argument is invalid\n\n\nis_positive_integer\n\n\n\nUtils.is_positive_integer(arg)\n\n\n\n\nVerifies argument is a valid int constructor.\n\n\nArgs:\n    arg (\nint\n or \nstr\n): Argument to be validated\n\n\nReturns:\n    \nTrue\n if valid\n    \nFalse\n if invalid\n\n\nadd_disallowed_char\n\n\n\nUtils.add_disallowed_char(arg)\n\n\n\n\nAdd character that cannot be used in search.\n\n\nArgs:\n    arg (\nstr\n): character to be added\n\n\nRaises:\n    \nArgumentError\n: if arg is not of type str\n\n\nremove_disallowed_char\n\n\n\nUtils.remove_disallowed_char(arg)\n\n\n\n\nMake a previously disallowed search character valid.\n\n\nArgs:\n    arg (\nstr\n): character to be removed\n\n\nRaises:\n    \nArgumentError\n: if arg is not of type str\n\n\nset_disallowed_chars\n\n\n\nUtils.set_disallowed_chars(arg)\n\n\n\n\nOverride existing set of disallowed search characters.\n\n\nArgs:\n    arg (\nset\n): set of characters\n\n\nRaises:\n    \nArgumentError\n: if any char in set is empty or len(char) > 1\n\n\nis_allowed_char\n\n\n\nUtils.is_allowed_char(arg)\n\n\n\n\nVerifies character is an allowed.\n\n\nArgs:\n    arg (\nstr\n): character to be validated\n\n\nReturns:\n    \nTrue\n if valid\n    \nFalse\n if invalid\n\n\nRaises:\n    \nArgumentError\n: if arg is not of type str\n\n\nis_allowed_str\n\n\n\nUtils.is_allowed_str(arg)\n\n\n\n\nVerifies string is an allowed.\n\n\nArgs:\n    arg (\nstr\n): string to be validated\n\n\nReturns:\n    \nTrue\n if valid\n    \nFalse\n if invalid",
            "title": "Utils"
        }
    ]
}